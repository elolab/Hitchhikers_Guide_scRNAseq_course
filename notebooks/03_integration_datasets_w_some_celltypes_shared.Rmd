---
title: "The Hitchhiker's Guide to scRNA-seq"
author: ""
date: "`r format(Sys.Date(), '%d/%m/%Y')`"
output: 
   html_document:
      toc: true 
      toc_float: true
      theme: united
      code_folding: hide
---

<br>

<br>

---

<br>

<br>

# Notebook

<br>

```{r setup, include=FALSE}
## Set up configuration for R chunks
knitr::opts_chunk$set(
	echo = TRUE,
	fig.align = "center",
	message = FALSE,
	warning = FALSE
)
```

```{r packages, message=FALSE, warning=FALSE}
## Import packages
library("dplyr") 
library("Seurat") # scRNA-seq analysis
library("patchwork")
if (!"SeuratWrappers" %in% installed.packages()) remotes::install_github("satijalab/seurat-wrappers", "seurat5")
library("SeuratWrappers")
if (!"batchelor" %in% installed.packages()) BiocManager::install("batchelor")
if ((!"matrixStats" %in% installed.packages()) | (packageVersion("matrixStats")>"1.1.0")) {
  remotes::install_version("matrixStats", version="1.1.0")
} 
if (!"ComplexHeatmap" %in% installed.packages()) remotes::install_github("jokergoo/ComplexHeatmap")
if (!"zellkonverter" %in% installed.packages()) BiocManager::install("zellkonverter")
```

<br>

<br>

---

<br>

<br>

## (1) Import datasets 

_(7 min)_

<br>

```{r import data}
# Import data
data.dir <- "../data"
seu <- readRDS(file = file.path(data.dir, "jurkat.rds"))
```

<br>

### Downsample dataset 

<br>

You may want to down sample this data set depending on the amount of RAM memory you have. The `jurkat` data set has 8,664 cells. 

```{r downsample data set}
## Downsample data set
downsample <- TRUE # replace to FALSE in case you don't want to down sample
prop.down <- 0.4 # proportion of cells to down sample per batch: 40% of the cells
if (downsample) {
  no.cells.batch <- ceiling(table(seu$batch) * 0.4) # CTRL = 1310 and STIM = 1491 
  cell.idx.batch <- split(x = colnames(seu), f = seu$batch) # split into a list the cell names per batch
  cell.idx.batch.down <- lapply(X = setNames(names(cell.idx.batch), names(cell.idx.batch)), FUN = function(x) {
    set.seed(123)
    sample(x = cell.idx.batch[[x]], size = no.cells.batch[[x]], replace = FALSE)
  }) # downsample each batch cell names 
  cell.idx.downsample <- do.call(c, cell.idx.batch.down) # join cell name labels from the two batches into one character vector
  seu <- subset(seu, cells = cell.idx.downsample)
}
gc()
```

<br>

<br>

---

<br>

<br>

## (2) Assess batch effect

_(7 min)_

<br>

### Joint dimred

<br>

```{r joint dimred analysis}
## Joint analysis

# Standard Seurat upstream workflow
seu <- NormalizeData(seu)
seu <- FindVariableFeatures(seu)
seu <- ScaleData(seu)
seu <- RunPCA(seu)
seu <- RunUMAP(seu, dims = 1:30, reduction = "pca", reduction.name = "umap.unintegrated")
```

```{r plot joint dimreds, fig.width=10, fig.height=4}
## Plot jointly dimreds
pca.unint <- DimPlot(seu, reduction = "pca", group.by = "batch")
umap.unint <- DimPlot(seu, reduction = "umap.unintegrated", group.by = "batch")
pca.unint + umap.unint
```

<br>

### Celltype markers

<br>

```{r joint celltype markers}
## Joint celltype markers

# List of jurkat and T293 cell lines
markers.plot <- list(
  "jurkat" = "CD3D", 
  "t293" = "XIST"
)

# Plot
jurkat.markers.unint.plot <- FeaturePlot(seu, features = markers.plot$jurkat, split.by = "batch", 
                                       max.cutoff = 3, cols = c("grey", "red"), 
                                       reduction = "umap.unintegrated", ncol = 4, 
                                       pt.size = 0.5)
t293.markers.unint.plot <- FeaturePlot(seu, features = markers.plot$t293, split.by = "batch", 
                                           max.cutoff = 3, cols = c("grey", "red"), 
                                           reduction = "umap.unintegrated", ncol = 4, 
                                           pt.size = 0.5)
```

```{r plot joint celltype markers, fig.width=12, fig.height=4}
## Plot jointly celltype markers

# Print 
jurkat.markers.unint.plot 
t293.markers.unint.plot
```

<br>

### Manual cell annotation

<br>

```{r independent sample analysis}
## Independent sample analysis

# Split Seurat object into two batch on 'batch' label identity
seu.list <- SplitObject(object = seu, split.by = "batch")

# Standard Seurat upstream workflow
seu.list <- lapply(X = seu.list, FUN = function(x) {
  x <- NormalizeData(x)
  x <- FindVariableFeatures(x)
  x <- ScaleData(x)
  x <- RunPCA(x)
  x <- FindNeighbors(x, dims = 1:15, reduction = "pca")
  x <- FindClusters(x, resolution = 0.1, cluster.name = "unintegrated_clusters")
  x <- RunUMAP(x, dims = 1:15, reduction = "pca", reduction.name = "umap.unintegrated")
})
```

```{r plot independent sample analysis clusters, fig.width=10, fig.height=4}
## Plot independent sample analysis clusters
umap.ind.samp.unint <- lapply(X = seu.list, FUN = function(x) {
  DimPlot(x, reduction = "umap.unintegrated", group.by = "unintegrated_clusters", pt.size = 0.5)
})
umap.ind.samp.unint$t293 + umap.ind.samp.unint$jurkat + umap.ind.samp.unint$`jurkat_t293_50:50`
```

<br>

<br>

---

<br>

<br>

## (3) Integrate datasets

_(7 min)_

<br>

```{r integration}
## Perform integration

# Split layers for integration
seu[["RNA"]] <- split(x = seu[["RNA"]], f = seu$batch)

# Standard workflow
seu <- NormalizeData(seu)
seu <- FindVariableFeatures(seu)
seu <- ScaleData(seu)
seu <- RunPCA(seu)

# Integrate layers
int.methods <- c("CCA" = "CCAIntegration", "RPCA" = "RPCAIntegration", 
                 "Harmony" = "HarmonyIntegration", "FastMNN" = "FastMNNIntegration", 
                 "scVI" = "scVIIntegration")

for (m in names(int.methods)[1:4]) {
  cat("\nRunning integration method", m, "...\n")
  int.dimred <- paste0("integrated.", m)
  umap.dimred <- paste0("umap.", m)
  # Integration
  if (m=="scVI") {
          seu <- IntegrateLayers(object = seu, method = get(eval(substitute(int.methods[m]))), 
                         orig.reduction = "pca", 
                         new.reduction = int.dimred,
                         conda_env = "/home/aggs/miniconda3/envs/scvi-env", # substitute this by your installation 
                         verbose = TRUE)
  } else {
      seu <- IntegrateLayers(object = seu, method = get(eval(substitute(int.methods[m]))), 
                         orig.reduction = "pca", 
                         new.reduction = int.dimred,
                         verbose = TRUE)
  }

}

# Re-join layers after integration
seu[["RNA"]] <- JoinLayers(seu[["RNA"]])

# Run UMAP for every integration method
int.umaps.plots <- list()
for (m in names(int.methods)[1:4]) {
  cat("\nRunning UMAP for", m, "integrated result...\n")
  int.dimred <- paste0("integrated.", m)
  umap.dimred <- paste0("umap.", m)
  seu <- RunUMAP(seu, dims = 1:30, reduction = int.dimred, reduction.name = umap.dimred)
  int.umaps.plots[[m]] <-  DimPlot(object = seu, reduction = umap.dimred, group.by = c("batch", "cell_type"), 
                                   combine = FALSE, label.size = 2)
}
```

<br>

<br>

---

<br>

<br>

## (4) Assess integration

_(7 min)_

<br>

```{r assess integration - plot, fig.width=16, fig.height=20}
## Assess integration by printing the plots using the "batch" and "cell_type" (ground-truth) labels
wrap_plots(c(int.umaps.plots$CCA, int.umaps.plots$RPCA, int.umaps.plots$Harmony, int.umaps.plots$FastMNN),
           ncol = 2, byrow = TRUE)
```

<br>

<br>

---

<br>

<br>

#### R packages used and respective versions

<br>

```{r References, message=FALSE, warning=FALSE, paged.print=FALSE}
## R packages and versions used in these analyses
sessionInfo()
```

<br>

<br>

---

<br>

<br>
